# springstudy
스프링에 대해 학습하면서 정리하는 개인 Repo

## 멀티쓰레드에 대해
### 왜 써?
인터페이스의 파라미터 값을 변경해 각각의 log 정보를 남긴다면 매우 비효율적인 과정이고 이를 해결하기 위해
LogTrace 필드를 활용해 이를 호출함으로써 인터페이스 변경없이 처리한다.
하지만 이는 동시에 여러 요청이 들어온 케이스에 대해 처리할 수 없다. <br>
LogTrace는 싱글톤객체이기때문에 해당 빈이 공유되어버리는 문제가 발생한다.
이를 해결하기 위해 ThreadLocal을 사용한다.
ThreadLocal은 각각의 Thread에 대해 독립적인 데이터 저장소를 사용할 수 있어서 A사용자의 요청 정보가
B사용자의 로그에 노출되어질 일이 없어진다.

### 주의사항
ThreadLocal 사용 시 전용 저장소에 각각의 thread의 정보를 저장한 뒤 WAS가 응답한다.
WAS는 thread pool을 쓰레드 풀에 반환하고 재사용한다.
만약 thread-A가 살아있다면 사용자 A의 정보도 그대로 남아있다.
이후 사용자 B가 조회하는 API를 요청했고 하필 쓰레드 A에서 처리한다면 쓰레드 A가 저장했었던
사용자 A의 정보가 반환되서 사용자B는 사용자A의 정보를 보게된다.

그러므로 HTTP 요청이 끝날 때 Thread Local의 값을 remove를 통해 꼭 제거해줘야한다.

### 템프릿 메서드 패턴 - 시작 
로그 추적기 적용을 하니 서비스는 코드 한줄로 끝나는데 이외 부가 기능(로그 추적)을 처리 하기 위한 코드가 너무 많고 복잡해지는 문제가 발생한다.
- 핵심기능 (비즈니스 로직)
- 부가기능 (ex: 로그 추적 기능, 애플리케이션의 기능 보조)
- 변하는 부분과 변하지 않는 부분을 분리해서 메서드화 시킨다.
- TemplateMethodTest 참조
- 변하는 부분을 하위클래스로 변하지 않는 부분을 상위클래스로 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고 , 일부 변경되는 로직은 자식 클래스에 정의하는 구조
- 하지만 해당 패턴은 '상속'을 사용한다. 자식 클래스가 부모 클래스를 의존하고 있다.

### 전략패턴
- 변하지 않는 부분을 Context라는 부분에 둔다.
- 변하는 부분을 Streaty에 둔다.(Strategy는 변하는 알고리즘 역할)
- 상속이 아닌 위임으로 해결한다.(구성)
- 전략을 사용하면 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.